# Рекурсия

Данные задания предназначены для отработки навыков по созданию программ с помощью рекурсии.

# Задания и инструкции 

Любая рекурсия заключается в том, что функция вызывает сама себя. Для этого определение функции должно быть представимо 
в виде рекурентного соотношения. Кроме того, должна существовать база рекурсии: некоторые значения аргументов функции 
при которых значение известно. Иначе рекурсия никогда не завершится и получится StackOverFlowError 

## Факториал числа
В данном задании необходимо реализовать факториал числа

Рекурентное соотношение:
n! = n * (n-1)!
    
База рекурсии: 0! = 1

```java
/**
     *
     * @param n число
     * @return факториал числа n
     * <p>
     */
    public static int factorial(int n) {
        //TODO
        return 0;
    }
```

## Числа Фибоначи

В данном задании необходимо написать функцию, которая производит расчет чисел фибоначи.
Ряд Фибоначи:
1 1 2 3 5 8 13 21 ...

Следующее число равно сумме двух предыдущих чисел.

#### Рекурентное соотношение
fib(n) = fib(n-1) + fib(n-2)

#### База рекурсии 
В оригинале числа начинаются с 1. В более современных работах, т.к. программисты считают с нуля. "Нулевым" числом является нуль.
Т.е.
```
fibonachi(0) -> 0
fibonachi(1) -> 1
fibonachi(2) -> fibonachi(1) + fibonachi(0) -> 1
fibonachi(3) -> fibonachi(2) + fibonachi(1) -> 1+1 -> 2
```
и т.д.


Для решения задания реализуйте функцию fibonachi следующей сигнатуры:
```java
    /**
     *
     * @param n - номер числа Фибоначи в ряду.
     * @return возвращает число Фибоначи
     */
    static int fibonachi(int n) {
        //TODO
        return 0;
    }
```

> ПОДСКАЗКА: База рекурсии состоит из двух элементов последовательности.
     
## Алгоритм Евклида

Алгоритм Евклида нахождения наибольшего общего делителя двух чисел.
    
#### Рекурентное отношение
GCD(A,B) = GCD(B, A % B)

#### База рекурсии 
Рано или поздно число B станет равно нулю. Тогда число A и станет решением.

GCD(A,0) = A

Для решения задания необходимо реализовать функцию следующей сигнатуры:
```java
     /*
     *
     * @param a - число a
     * @param b - число b
     * @return наибольший общий делитель чисел а и b
     */
    static int gcd(int a, int b) {
        //TODO
        return 0;
    }
```

## Сумма чисел
Рекурсией можно заменить любой цикл. Рассмотрим рекурсию на примере суммирования чисел из интервалла.

Вычислить сумму чисел из интервалла [a; b] включительно

#### Рекурентное соотношение
sum(a,b) = a + sum(a+1,b)

#### База рекурсии
Если левая граница интервалла больше правой, то нет чисел для суммирования и сумма равна нулю.

Для решения задачи, реализуйте функцию следующей сигнатуры:
```java     
/*
 * @param a левая граница интервалла.
 * @param b правая граница интервалла.
 * @return возвращает сумму целых чисел из интервалла
 */
static int sum(int a, int b) {
    //TODO
    return 0;
}
```


## Треугольник Паскаля

1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
...........

Числа на грани треугольника все равны 1, и каждое число внутри триугольника равно сумме двух чисел сверху него.

Напишите функцию, которая вычисляет элементы треугольника Паскаля с помощью рекурсивного процесса.
Например, 
```
pascal(0,2) -> 1
pascal(1,2) -> 2
pascal(1,3) -> 3
```

Попробуйте самостоятельно определить, какое должно быть рекурентное соотношение и база рекурсии.

Выполните это задание, реализуя функцию pascal, которая принимает на вход столбец c и строку r, начиная отсчет с 0
и возвращает число в этой точке в треугольнике.

```java
    /**
     *
     * @param c - column, столбец. Левая грань треугольника является нулевым столбцом. Следующая параллельная диагональ 1-м столбцом и т.д.
     * @param r - row, строка или горизонталь треугольника. Вершина треугольника - строка с номером 0.
     * @return возвращает число, стоящее в указанной позиции в треугольнике Паскаля.
     */
    static int pascal(int c, int r) {
        //TODO
        return 0;
    }
```

## Размен монет
Имеется сумма денег, которую нужно разменять и номиналы монет. Нужно определить, сколько существует возможных комбинаций размена.

Напишите рекурсивную функцию, которая подсчитывает, как много различных способов 
вы можете предложить для размена суммы, имея список номиналов монет.

Например, есть три способа разменять 4 если у вас есть монеты достоинством 1 и 2: 
```
1+1+1+1
1+1+2
2+2
```

Выполните это задание, реализовав функцию countChange.
Эта функция принимает сумму для размена и список уникальных номиналов монет.

Вы можете использовать coins.get(0) для получения первого элемента списка.
```java
int firstCoin = coins.get(0);
```

Вы можете использовать coins.subList(1) для списка элементов за исключением первого элемента.
```java
List<Integer> theRest = coins.subList(1);
```

Вы можете использовать coins.isEmpty() для проверки списка на пустоту.

```java
boolean found = coins.isEmpty();
```
> Подсказка: Подумайте о вырожденных случаях
> Как много способов для размена суммы равной 0?
Как много способов для размена для суммы >0 , если у вас нет монет?

>Подсказка: отрицательную сумму денег разменять нельзя.
Количество способов размена в этом случае равно 0.
```java
/*
 *
 * @param money - сумма денег которую нужно разменять
 * @param coins - спиоок номиналов монет, доступных для размена. У нас неограниченное количество монет каждого номинала.
 * @return возвращает количество возможных вариантов размена суммы money монетами имеющихся номиналов coins
 */
static int countChange(int money, List<Integer> coins) {
    //TODO
    return 0;
}
```

## Поиск файлов
Рекурсия широко применяется для обработки структур в виде дерева.

Напишите рекурсивную функцию, которая выводит список файлов и папок,
удовлетворяющих условию поиска. Нужно найти файл или папку,
начиная с пути path, заходя во все подпапки,
в названии которого есть подстрока name.

Для этого вам потребуется использовать класс java.io.File
Для того чтобы создать объект класса File по указанному пути используйте
```java
File dir = new File(pathToDir);
```

Для начала необходимо проверить, существует ли путь, в котором нужно искать.
Для этого можно воспользоваться методом File.exists()

```java
File file = ...  
if (file.exists) {
    // файл или каталог существует, обрабатываем...
}
```

Для того чтобы разделить файлы и директории существует метод isFile() и isDirectory()
```java
boolean isFile = file.isFile();
boolean isDir = file.isDirectory();
```

У класса File есть метод позволяющий получить все файлы и поддиректории в этой директории
```java
File[] children = dir.listFiles();
```
     
Для того чтобы получить имя файла и его путь можно использовать методы getName(), getPath()
```java
String name = file.getName();
String fullPath = file.getPath();
```

Для решения задания реализуйте функцию findFile следующей сигнатуры:
```java
/*
 *
 * @param path папка с которой нужно начать поиск
 * @param name часть имени файла или папки
 */
static void findFile(String path, String name) {
   //TODO
}
```