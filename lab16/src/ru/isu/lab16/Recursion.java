package ru.isu.lab16;

import java.util.List;

/**
 * TODO изменить автора на свое имя и фамилию
 *
 * @author Vladimir Ulyanov
 */
public class Recursion {

    /**
     * Факториал числа n или n!
     * <p>
     * n            0 1 2 3 4  ...
     * n!           1 1 2 6 24 ...
     * <p>
     * Рекурентное соотношение:
     * n! = n * (n-1)!
     * <p>
     * База рекурсии:
     * 0! = 1
     *
     * @param n число
     * @return факториал числа n
     * <p>
     * 5! = 120
     */
    public static int factorial(int n) {
        //TODO
        return (n == 0) ? 1 : n * factorial(n - 1);
    }


    /**
     * Расчет чисел фибоначи.
     * Ряд Фибоначи:
     * 1 1 2 3 5 8 13 21 ...
     * <p>
     * Следующее число равно сумме двух предыдущих чисел.
     * Рекурентное соотношение:
     * fib(n) = fib(n-1) + fib(n-2)
     * <p>
     * В качестве базы рекурсии:
     * В оригинале числа начинаются с 1. В более современных работах, т.к. программисты считают с нуля. "Нулевым" числом является нуль.
     * Т.е.
     * fibonachi(0) = 0
     * fibonachi(1) = 1
     * fibonachi(2) = fibonachi(1) + fibonachi(0) = 1
     * и т.д.
     * <p>
     * ПОДСКАЗКА: База рекурсии состоит из двух элементов последовательности.
     *
     * @param n - номер числа Фибоначи в ряду.
     * @return возвращает число Фибоначи
     */
    static int fibonachi(int n) {
        //TODO
        return 0;
    }


    /**
     * Алгоритм Евклида нахождения наибольшего общего делителя двух чисел
     * <p>
     * рекурентное отношение:
     * GCD(A,B) = GCD(B, A % B)
     * <p>
     * В качестве базы рекурсии:
     * Рано или поздно число B станет равно нулю.
     * GCD(A,0) = A
     *
     * @param a - число a
     * @param b - число b
     * @return наибольший общий делитель чисел а и b
     */
    static int gcd(int a, int b) {
        //TODO
        return 0;
    }


    /**
     * Сумма чисел из интервалла [a; b] включительно
     * <p>
     * Рекурентное соотношение:
     * sum(a,b) = a + sum(a+1,b)
     * <p>
     * База рекурсии:
     * Если левая граница интервалла больше правой, то нет чисел для суммирования и сумма равна нулю.
     *
     * @param a левая граница интервалла.
     * @param b правая граница интервалла.
     * @return возвращает сумму целых чисел из интервалла
     */
    static int sum(int a, int b) {
        //TODO
        return 0;
    }

    /**
     * ТРЕУГОЛЬНИК ПАСКАЛЯ
     * <p>
     * 1
     * 1 1
     * 1 2 1
     * 1 3 3 1
     * 1 4 6 4 1
     * <p>
     * Числа на грани треугольника все равны 1, и каждое число внутри триугольника равно сумме двух чисел сверху него.
     * Напишите функцию, которая вычисляет элементы треугольника Паскаля с помощью рекурсивного процесса.
     * Выполните это задание, реализуя функцию pascal, которая принимает на вход столбец c и строку r, начиная отсчет с 0
     * и возвращает число в этой точке в треугольнике.
     * Например, pascal(0,2)=1, pascal(1,2)=2 и pascal(1,3)=3.
     *
     * @param c - column, столбец. Левая грань треугольника является нулевым столбцом. Следующая параллельная диагональ 1-м столбцом и т.д.
     * @param r - row, строка или горизонталь треугольника. Вершина треугольника - строка с номером 0.
     * @return возвращает число, стоящее в указанной позиции в треугольнике Паскаля.
     */
    static int pascal(int c, int r) {
        //TODO
        return 0;
    }

    /**
     * Напишите рекурсивную функцию, которая подсчитывает, как много различных способов
     * вы можете предложить для размена суммы, имея список номиналов монет.
     * Например, есть три способа разменять 4 если у вас есть монеты достоинством 1 и 2: 1+1+1+1, 1+1+2, 2+2.
     * Выполните это задание, реализовав функцию countChange.
     * Эта функция принимает сумму для размена и список уникальных номиналов монет.
     * <p>
     * Вы можете использовать coins.get(0) для получения первого элемента списка.
     * Вы можете использовать coins.subList(1) для списка элементов за исключением первого элемента.
     * Вы можете использовать coins.isEmpty() для проверки списка на пустоту.
     * <p>
     * Подсказка: Подумайте о вырожденных случаях.
     * Как много способов для размена суммы равной 0?
     * Как много способов для размена для суммы >0 , если у вас нет монет?
     * <p>
     * Подсказка: отрицательную сумму денег разменять нельзя.
     * Количество способов размена в этом случае равно 0.
     *
     * @param money - сумма денег которую нужно разменять
     * @param coins - спиоок номиналов монет, доступных для размена. У нас неограниченное количество монет каждого номинала.
     * @return возвращает количество возможных вариантов размена суммы money монетами имеющихся номиналов coins
     */
    static int countChange(int money, List<Integer> coins) {
        //TODO
        return 0;
    }

    /**
     * Напишите рекурсивную функцию, которая выводит список файлов и папок,
     * удовлетворяющих условию поиска. Нужно найти файл или папку,
     * начиная с пути path, заходя во все подпапки,
     * в названии которого есть подстрока name.
     * <p>
     * Для этого вам потребуется использовать класс java.io.File
     * Для того чтобы создать объект класса File по указанному пути используйте
     * <p>
     * File dir = new File(pathToDir);
     * <p>
     * Для начала необходимо проверить, существует ли путь, в котором нужно искать.
     * Для этого можно воспользоваться методом File.exists()
     * File file = ...  ;
     * if (file.exists) {
     * // файл или каталог существует, обрабатываем...
     * }
     * <p>
     * У класса File есть метод позволяющий получить все файлы и поддиректории в этой директории
     * File[] children = dir.listFiles();
     * <p>
     * Для того чтобы разделить файлы и директории существует метод isFile() и isDirectory()
     * boolean isFile = file.isFile();
     * bolean isDir = file.isDirectory();
     * <p>
     * Для того чтобы получить имя файла и его путь можно использовать методы getName(), getPath()
     * String name = file.getName();
     * String fullPath = file.getPath();
     *
     * @param path папка с которой нужно начать поиск
     * @param name часть имени файла или папки
     */
    static void findFile(String path, String name) {

    }
}
