# Игра в слова "Балда"

Данная игра заключается в том, что оба игрока должны собирать слова из букв одного общего длинного слова. 
Игроки по очереди говорят по одному слову. Повторы не допускаются. 
За каждое правильное слово игроку начисляются очки равные количеству букв в слове.

# Задача
Задание ориентировано на отработку техники работы со списками в Java. 
Задача заключается в том, чтобы дописать искусственный интеллект компьютерного игрока в приложении.
Места, необходимые для реализации помечены аннотацией
```java
//TODO <Инструкции>
```

В данном приложении организована игра человека с компьютером. Есть словарь русского языка, который находится в файле [zdf-win.txt](zdf-win.txt).

1. Необходимо реализовать фильтрацию подходящих слов для игры (слова с дефисами не допускаются)
2. Реализовать выбор ТОП-N слов максимальной длины из которых можно собирать другие слова. 
3. Необходимо реализовать функцию сравнения двух слов по длине (по-умолчанию строки сравниваются лексикографически)
4. Реализовать проверку, можно ли составить маленькое слово из большого на основе их частотных показателей
5. Реализовать теоретико-множественную разность двух списков
6. Реализовать функцию, которая подсчитывает изменения в счете игроков

# Тесты
В классе [Tests](src/ru/isu/lab14/words/Tests.java) находится набор тестов для проверки корректности Вашей работы.
Запустить их можно создав конфигурацию `JUnit`, либо запустить тесты по правой кнопке мыши, выбрав в контекстном меню пункт `Run`.
По мере реализации методов по инструкциям перезапускайте тесты, чтобы убедиться, что соответствующие тесты проходят и вы все делаете верно.

# Инструкции
Данные инструкции помогут вам последовательно решить все задачи. Для этого нужно открыть класс [Words](src/ru/isu/lab14/words/Words.java) и реализовать ряд функций   
##Фильтрация подходящих слов
Реализуйте метод `withoutDefis` для фильтрации слов, содержащих символ дефиса (`-`)
```java
public static List<String> withoutDefis(final List<String> dictionary) {}
```    
Для этого в цикле переберите все слова из исходного списка `dictionary` и если слово не содержит дефис, добавьте его в результирующий список.

## Сортировка слов
Для сортировки в Java используется метод `java.util.List.sort(Comparator)`. Имея список строк, можно его отсортировть, вызвав данный метод.
Но проблема в том, что по-умолчанию строки сортируются лексикографически, а в нашем случае, надо отсортировать по длине - от самого длинного к самому короткому.
Для этого необходимо реализовать интерфейс `Comparator`
Реализуйте функцию
````java
 public static Comparator<String> lengthComparator(){
        return new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                //TODO реализовать функцию сравнения двух слов по длине
                return 0;
            }
        };
    }
````
Функция `compare` возвращает число, величина коттрого не важна, а важен знак. Если для пары объектов возвращается отрицательное число , то первое слово "меньше" второго.
Следовательно он при сортировке должен быть раньше (по-умолчанию сортировка идет по убыванию).

В нашем случае, необходимо сравнивать по строки по длине, причем, не по возрастанию, а по убыванию. Т.е. 

`compare("Презумпкция", "адвокат")` должно возвращать отрицательное число, а `compare("дом", "здание")` должно возвращать положительное число.
 Если слова одинаковой длины, они считаются несравнивыми и в данном случае должен быть возвращен ноль. 
 Например, `compare("книга", "мозги")` должно вернуть `0`.
 
 > Подсказка: для реализации воспользуйтесь методом length() в классе String, который возвращает длину строки.

## ТОП
Далее возмьем несколько самых длинных слов словаря. Для этого реализуйте метод 
```java
public static List<String> top(List<String> list){}
```
Он принимает на вход список слов, а возвращает список слов длины `TOP_SIZE`. 

> Подсказка: воспользуйтесь методом `List.subList(size)`.

## Одно из другого
Чтобы реализовать искусственный интеллект, нам необходимо уметь выяснять, можно ли составить из одного слово, другое.
Тогда мы могли бы пробегать по отсортированному словарю и брать первое попавшееся подходящее слово. 

Для начала посмотрите на функцию `frequency`, она принимает на вход строку и возвращает частотные характеристики слова.
 Map<Character, Integer> содержит пары ("ключ"-"значение"). В нашем случае для каждого символа сопоставляется сколько раз оно встречается в слове.
 Например для слова `молоко` получится  `(м - 1, о - 3, л - 1, к - 1)`, а для слова `ком` будет `(к - 1, о - 1, м - 1)`. 

Одно слово можно составить из другого, если для каждой буквы в маленьком слове ее количество меньше, чем в большом слове.
 
Чтобы решить такую задачу, реализуйте метод

```java
public static boolean contains(Map<Character, Integer> big, Map<Character, Integer> small) {}
```

Данный метод принимает на вход частотные характеристики двух слов и возвращает true если из слова `big` можно составить слово `small`
Например, из слова `молоко` можно составить слово `ком`, так как каждая буква слова `ком` встречается меньшее количество раз, чем в слове `молоко`.
> Подсказка: Организуйте цикл по ключам, воспользовавшись `Map.keySet()` и получением значения по ключу `Map.getOrDefault(key, defauleValue)`

## Без повторов
Чтобы не было повторов, необходимо использованное слово исключить из списка. Для этого нам потреубется метод, реализующий теоретико-множественную разность:
```java
public static List<String> minus(List<String> list, List<String> sub) {}
```
Воспользуйтесь аналогичной техникой итерации списка. 
> Подсказка Вам может пригодиться метод `Collection.contains(element)`, который проверяет, содержит ли данный список указанный элемент.

# Запуск
Когда все тесты проходят, можно запустить на выполнение класс [Words](src/ru/isu/lab14/words/Words.java) и протестировать игру в действии. 
